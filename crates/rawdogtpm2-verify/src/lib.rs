// SPDX-License-Identifier: MIT OR Apache-2.0

//! Attestation verification for TPM and Nitro attestations
//!
//! This crate provides verification of attestation documents generated by rawdogtpm2:
//! - TPM attestation verification with EK public key matching
//! - X.509 certificate chain validation
//! - AWS Nitro COSE Sign1 document verification
//! - Root certificate public key hash extraction (SHA-256, hex-encoded)

mod error;
mod nitro;
mod tpm;
mod x509;

use std::collections::BTreeMap;

use serde::Serialize;

// Re-export error type
pub use error::VerifyError;

// Re-export TPM types and functions
pub use tpm::{verify_ecdsa_p256, verify_tpm_attestation, TpmVerifyResult};

// Re-export Nitro types and functions
pub use nitro::{verify_nitro_attestation, NitroDocument, NitroVerifyResult};

// Re-export X.509 utility functions
pub use x509::{
    extract_public_key, hash_public_key, parse_cert_chain_pem, validate_cert_chain,
};

// Re-export types from rawdogtpm2 for convenience
pub use rawdogtpm2::a9n::{
    AttestationContainer, AttestationData, AttestationOutput, EkCertificates, EkPublicKey,
    NitroAttestationData,
};

/// Summary of verification for an entire AttestationOutput
#[derive(Debug, Serialize)]
pub struct VerificationSummary {
    /// TPM verification results by key type
    pub tpm: BTreeMap<String, TpmVerifyResult>,
    /// Nitro verification result (if present)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nitro: Option<NitroVerifyResult>,
}

/// Verify an entire AttestationOutput
///
/// Verifies all TPM attestations and the Nitro attestation (if present).
/// For TPM attestations, this verifies:
/// 1. EK public key from attestation matches the certificate's EK public key
/// 2. AK signature over the nonce is valid
/// 3. Certificate chain validates to root CA
pub fn verify_attestation_output(
    output: &AttestationOutput,
) -> Result<VerificationSummary, VerifyError> {
    let mut tpm_results = BTreeMap::new();

    // Verify each TPM attestation
    for (key_type, attestation) in &output.attestation.tpm {
        // Get the corresponding EK certificate
        let ek_cert = match key_type.as_str() {
            "rsa_2048" => output.ek_certificates.rsa_2048.as_ref(),
            "ecc_p256" => output.ek_certificates.ecc_p256.as_ref(),
            "ecc_p384" => output.ek_certificates.ecc_p384.as_ref(),
            _ => None,
        };

        // Get the corresponding EK public key from attestation output
        let ek_pubkey = output.ek_public_keys.get(key_type);

        // Get the corresponding signing key (AK) public key
        let ak_pubkey = output.signing_key_public_keys.get(key_type);

        if let (Some(cert_pem), Some(ek_pk), Some(ak_pk)) = (ek_cert, ek_pubkey, ak_pubkey) {
            let result = verify_tpm_attestation(
                &attestation.attest_data,
                &attestation.signature,
                &ak_pk.x,
                &ak_pk.y,
                &ek_pk.x,
                &ek_pk.y,
                cert_pem,
            )?;
            tpm_results.insert(key_type.clone(), result);
        }
    }

    // Verify Nitro attestation if present
    let nitro_result = if let Some(ref nitro) = output.attestation.nitro {
        Some(verify_nitro_attestation(
            &nitro.document,
            None, // Don't validate nonce here
            None, // Don't validate pubkey here
        )?)
    } else {
        None
    };

    Ok(VerificationSummary {
        tpm: tpm_results,
        nitro: nitro_result,
    })
}
